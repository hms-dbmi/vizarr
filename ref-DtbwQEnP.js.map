{"version":3,"file":"ref-DtbwQEnP.js","sources":["../node_modules/.pnpm/reference-spec-reader@0.2.0/node_modules/reference-spec-reader/src/render.js","../node_modules/.pnpm/reference-spec-reader@0.2.0/node_modules/reference-spec-reader/src/parse.js","../node_modules/.pnpm/reference-spec-reader@0.2.0/node_modules/reference-spec-reader/src/store.js","../node_modules/.pnpm/@zarrita+storage@0.1.0/node_modules/@zarrita/storage/dist/src/ref.js"],"sourcesContent":["/**\n * @param {string} template\n * @param {RegExp=} re\n */\nfunction parse(template, re = /{{(.*?)}}/) {\n\tlet result = re.exec(template);\n\tconst parts = [];\n\tlet pos;\n\n\twhile (result) {\n\t\tpos = result.index;\n\t\tif (pos !== 0) {\n\t\t\tparts.push({ match: false, str: template.substring(0, pos) });\n\t\t\ttemplate = template.slice(pos);\n\t\t}\n\t\tparts.push({ match: true, str: result[0] });\n\t\ttemplate = template.slice(result[0].length);\n\t\tresult = re.exec(template);\n\t}\n\n\tif (template) {\n\t\tparts.push({ match: false, str: template });\n\t}\n\n\treturn parts;\n}\n\n/** @param {string} str */\nfunction matchFn(str) {\n\tconst match = str.match(/(?<fname>[A-Z_][A-Z_1-9]*)\\((?<args>[^)]+)\\)/i);\n\tif (!match?.groups) return;\n\n\tconst { fname, args } = match.groups;\n\tconst ctx = Object.fromEntries(\n\t\targs.split(\",\").map((kwarg) => {\n\t\t\tconst { key, num, str } =\n\t\t\t\tkwarg.match(\n\t\t\t\t\t/(?<key>[a-z_0-9]*)\\s*=\\s*((?<num>[0-9.]+)|('|\")(?<str>.*)('|\"))/i,\n\t\t\t\t)?.groups ?? {};\n\t\t\tif (!key || !(num || str)) {\n\t\t\t\tthrow Error(`Failed to match fn kwarg: ${kwarg}`);\n\t\t\t}\n\t\t\treturn [key, num ? Number(num) : str];\n\t\t}),\n\t);\n\n\treturn { fname, ctx };\n}\n\nconst alphabet = \"abcdefghijklmnopqrstuvwxyz\";\nconst numbers = \"01234569789\";\nconst expr = \"()*/+-\";\nconst space = \" \";\nconst valid = new Set(\n\talphabet + alphabet.toUpperCase() + numbers + expr + space,\n);\n/** @param {string} str */\nfunction matchMathEval(str) {\n\tfor (let i = 0; i < str.length; i++) {\n\t\tif (!valid.has(str.charAt(i))) return;\n\t}\n\treturn parse(str, /[A-Za-z_][A-Za-z0-9_]*/gi);\n}\n\n/** @type {import('./types.js').RenderFn} */\nexport function render(template, context) {\n\tconst grps = parse(template);\n\treturn grps\n\t\t.map((grp) => {\n\t\t\tif (!grp.match) {\n\t\t\t\treturn grp.str;\n\t\t\t}\n\n\t\t\tlet inner = grp.str.split(/{{|}}/).filter(Boolean)[0].trim();\n\t\t\tif (inner in context) {\n\t\t\t\treturn context[inner];\n\t\t\t}\n\n\t\t\tconst fnMatch = matchFn(inner);\n\t\t\tif (fnMatch) {\n\t\t\t\tconst { fname, ctx } = fnMatch;\n\t\t\t\tconst fn = context[fname];\n\t\t\t\tif (typeof fn === \"function\") {\n\t\t\t\t\treturn fn(ctx);\n\t\t\t\t}\n\t\t\t\tthrow Error(\n\t\t\t\t\t`Cannot find function named ${fname} in rendering context.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst matches = matchMathEval(inner);\n\t\t\tif (matches) {\n\t\t\t\tconst exprParts = matches.map((match) => {\n\t\t\t\t\tif (!match.match) return match.str;\n\t\t\t\t\tconst value = context[match.str];\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\tthrow Error(\n\t\t\t\t\t\t\t`Cannot find number named ${match.str} in rendering context.`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof value !== \"number\") {\n\t\t\t\t\t\tthrow Error(\n\t\t\t\t\t\t\t`The provided value for ${match.str} must be a number.`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t});\n\t\t\t\treturn Function('\"use strict\";return (' + exprParts.join(\"\") + \")\")();\n\t\t\t}\n\n\t\t\tthrow new Error(`Unable to match ${grp.str}`);\n\t\t})\n\t\t.join(\"\");\n}\n","import { render } from \"./render.js\";\n\n/**\n * @param {import('./types.js').ReferencesV0 | import('./types.js').ReferencesV1} spec\n * @param {import('./types.js').RenderFn=} renderString\n */\nexport function parse(spec, renderString = render) {\n\t// @ts-ignore\n\treturn \"version\" in spec ? parseV1(spec, renderString) : parseV0(spec);\n}\n\n/**\n * @param {import('./types.js').ReferencesV0} spec\n * @returns {Map<string, import('./types.js').Ref>}\n */\nfunction parseV0(spec) {\n\treturn new Map(Object.entries(spec));\n}\n\n/**\n * @param {import('./types.js').ReferencesV1} spec\n * @param {import('./types.js').RenderFn} renderString\n * @returns {Map<string, import('./types.js').Ref>}\n */\nfunction parseV1(spec, renderString) {\n\t/** @type {import('./types.js').RenderContext} */\n\tconst context = {};\n\tfor (const [key, template] of Object.entries(spec.templates ?? {})) {\n\t\t// TODO: better check for whether a template or not\n\t\tif (template.includes(\"{{\")) {\n\t\t\t// Need to register filter in environment\n\t\t\tcontext[key] = (ctx) => renderString(template, ctx);\n\t\t} else {\n\t\t\tcontext[key] = template;\n\t\t}\n\t}\n\n\t/** @type {(t: string, o?: Record<string, string | number>) => string} */\n\tconst render = (t, o) => {\n\t\treturn renderString(t, { ...context, ...o });\n\t};\n\n\t/** @type {Map<string, import('./types.js').Ref>} */\n\tconst refs = new Map();\n\n\tfor (const [key, ref] of Object.entries(spec.refs ?? {})) {\n\t\tif (typeof ref === \"string\") {\n\t\t\trefs.set(key, ref);\n\t\t} else {\n\t\t\tconst url = ref[0]?.includes(\"{{\") ? render(ref[0]) : ref[0];\n\t\t\trefs.set(key, ref.length === 1 ? [url] : [url, ref[1], ref[2]]);\n\t\t}\n\t}\n\n\tfor (const g of spec.gen ?? []) {\n\t\tfor (const dims of iterDims(g.dimensions)) {\n\t\t\tconst key = render(g.key, dims);\n\t\t\tconst url = render(g.url, dims);\n\t\t\tif (\"offset\" in g && \"length\" in g) {\n\t\t\t\t// [url, offset, length]\n\t\t\t\tconst offset = render(g.offset, dims);\n\t\t\t\tconst length = render(g.length, dims);\n\t\t\t\trefs.set(key, [url, parseInt(offset), parseInt(length)]);\n\t\t\t} else {\n\t\t\t\t// [url]\n\t\t\t\trefs.set(key, [url]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn refs;\n}\n\n/**\n * @param {Record<string, import('./types.js').Range | number[]>} dimensions\n * @returns {Generator<Record<string, number>>}\n */\nfunction* iterDims(dimensions) {\n\tconst keys = Object.keys(dimensions);\n\tconst iterables = Object.values(dimensions).map((i) =>\n\t\tArray.isArray(i) ? i : [...range(i)],\n\t);\n\tfor (const values of product(...iterables)) {\n\t\tyield Object.fromEntries(keys.map((key, i) => [key, values[i]]));\n\t}\n}\n\n/** @param {...any[]} iterables */\nfunction* product(...iterables) {\n\tif (iterables.length === 0) {\n\t\treturn;\n\t}\n\t// make a list of iterators from the iterables\n\tconst iterators = iterables.map((it) => it[Symbol.iterator]());\n\tconst results = iterators.map((it) => it.next());\n\tif (results.some((r) => r.done)) {\n\t\tthrow new Error(\"Input contains an empty iterator.\");\n\t}\n\tfor (let i = 0; ; ) {\n\t\tif (results[i].done) {\n\t\t\t// reset the current iterator\n\t\t\titerators[i] = iterables[i][Symbol.iterator]();\n\t\t\tresults[i] = iterators[i].next();\n\t\t\t// advance, and exit if we've reached the end\n\t\t\tif (++i >= iterators.length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tyield results.map(({ value }) => value);\n\t\t\ti = 0;\n\t\t}\n\t\tresults[i] = iterators[i].next();\n\t}\n}\n\n/** @param {import('./types.js').Range} rng */\nfunction* range({ stop, start = 0, step = 1 }) {\n\tfor (let i = start; i < stop; i += step) {\n\t\tyield i;\n\t}\n}\n","import { parse } from \"./parse.js\";\n\nclass KeyError extends Error {\n\t__zarr__ = \"KeyError\";\n\t/** @param {string} msg */\n\tconstructor(msg) {\n\t\tsuper(msg);\n\t\tthis.name = \"KeyError\";\n\t}\n}\n\nexport class ReferenceStore {\n\t/**\n\t * @param {Map<string, import('./types.js').Ref>} references\n\t * @param {{ target?: string }=} opts\n\t */\n\tconstructor(references, opts = {}) {\n\t\tthis.ref = references;\n\t\tthis.target = opts.target;\n\t}\n\n\t/**\n\t * @param {string | import('./types.js').ReferencesV0 | import('./types.js').ReferencesV1} data\n\t * @param {{\n\t *   target?: string;\n\t *   renderString?: import('./types.js').RenderFn;\n\t * }=} opts\n\t */\n\tstatic fromJSON(data, opts = {}) {\n\t\tconst spec = typeof data === \"string\" ? JSON.parse(data) : data;\n\t\tconst ref = parse(spec, opts.renderString);\n\t\treturn new ReferenceStore(ref, opts);\n\t}\n\n\t/** @param {string} url */\n\t_url(url) {\n\t\tconst [protocol, path] = url.split(\"://\");\n\t\tif (protocol === \"https\" || protocol === \"http\") {\n\t\t\treturn url;\n\t\t}\n\t\tif (protocol === \"gc\") {\n\t\t\treturn `https://storage.googleapis.com/${path}`;\n\t\t}\n\t\tif (protocol === \"s3\") {\n\t\t\treturn `https://s3.amazonaws.com/${path}`;\n\t\t}\n\t\tthrow Error(\"Protocol not supported, got: \" + JSON.stringify(protocol));\n\t}\n\n\t/**\n\t * @param {{ url: string, offset?: number, size?: number }} props\n\t * @param {RequestInit} opts\n\t */\n\t_fetch({ url, offset, size }, opts) {\n\t\tif (offset !== undefined && size !== undefined) {\n\t\t\t// add range headers to request options\n\t\t\topts = {\n\t\t\t\t...opts,\n\t\t\t\theaders: {\n\t\t\t\t\t...opts.headers,\n\t\t\t\t\tRange: `bytes=${offset}-${offset + size - 1}`,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\treturn fetch(this._url(url), opts);\n\t}\n\n\t/**\n\t * @param {string} key\n\t * @param {RequestInit} opts\n\t */\n\tasync getItem(key, opts = {}) {\n\t\tconst entry = this.ref.get(key);\n\n\t\tif (!entry) {\n\t\t\tthrow new KeyError(key);\n\t\t}\n\n\t\tif (typeof entry === \"string\") {\n\t\t\tif (entry.startsWith(\"base64:\")) {\n\t\t\t\treturn __toBinary(entry.slice(7)).buffer;\n\t\t\t}\n\t\t\treturn __encoder.encode(entry).buffer;\n\t\t}\n\n\t\tconst [urlOrNull, offset, size] = entry;\n\t\tconst url = urlOrNull ?? this.target;\n\t\tif (!url) {\n\t\t\tthrow Error(`No url for key ${key}, and no target url provided.`);\n\t\t}\n\t\tconst res = await this._fetch({ url, offset, size }, opts);\n\n\t\tif (res.status === 200 || res.status === 206) {\n\t\t\treturn res.arrayBuffer();\n\t\t}\n\n\t\tthrow new Error(\n\t\t\t`Request unsuccessful for key ${key}. Response status: ${res.status}.`,\n\t\t);\n\t}\n\n\t/** @param {string} key */\n\tasync containsItem(key) {\n\t\treturn this.ref.has(key);\n\t}\n\n\tasync keys() {\n\t\treturn [...this.ref.keys()];\n\t}\n\n\t/**\n\t * @param {string} key\n\t * @param {ArrayBuffer} value\n\t * @returns {never}\n\t */\n\tsetItem(key, value) {\n\t\tthrow Error(\"FileReferenceStore.setItem is not implemented.\");\n\t}\n\n\t/**\n\t * @param {string} key\n\t * @returns {never}\n\t */\n\tdeleteItem(key) {\n\t\tthrow Error(\"FileReferenceStore.deleteItem is not implemented.\");\n\t}\n}\n\n/**\n * This is for the \"binary\" loader (custom code is ~2x faster than \"atob\") from esbuild.\n * https://github.com/evanw/esbuild/blob/150a01844d47127c007c2b1973158d69c560ca21/internal/runtime/runtime.go#L185\n * @type {(str: string) => Uint8Array}\n */\nconst __toBinary = (() => {\n\tvar table = new Uint8Array(128);\n\tfor (var i = 0; i < 64; i++) {\n\t\ttable[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;\n\t}\n\t// @ts-ignore\n\treturn (base64) => {\n\t\tvar n = base64.length;\n\t\tvar bytes = new Uint8Array(\n\t\t\t// @ts-expect-error\n\t\t\t(((n - (base64[n - 1] == \"=\") - (base64[n - 2] == \"=\")) * 3) / 4) | 0,\n\t\t);\n\t\tfor (var i = 0, j = 0; i < n; ) {\n\t\t\tvar c0 = table[base64.charCodeAt(i++)],\n\t\t\t\tc1 = table[base64.charCodeAt(i++)];\n\t\t\tvar c2 = table[base64.charCodeAt(i++)],\n\t\t\t\tc3 = table[base64.charCodeAt(i++)];\n\t\t\tbytes[j++] = (c0 << 2) | (c1 >> 4);\n\t\t\tbytes[j++] = (c1 << 4) | (c2 >> 2);\n\t\t\tbytes[j++] = (c2 << 6) | c3;\n\t\t}\n\t\treturn bytes;\n\t};\n})();\n\nconst __encoder = new TextEncoder();\n","import { parse } from \"reference-spec-reader\";\nimport { fetch_range, merge_init, strip_prefix, uri2href } from \"./util.js\";\n/**\n * This is for the \"binary\" loader (custom code is ~2x faster than \"atob\") from esbuild.\n * https://github.com/evanw/esbuild/blob/150a01844d47127c007c2b1973158d69c560ca21/internal/runtime/runtime.go#L185\n */\nlet table = new Uint8Array(128);\nfor (let i = 0; i < 64; i++) {\n    table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;\n}\nexport function to_binary(base64) {\n    const n = base64.length;\n    const bytes = new Uint8Array(\n    // @ts-ignore\n    (((n - (base64[n - 1] === \"=\") - (base64[n - 2] === \"=\")) * 3) / 4) | 0);\n    for (let i = 0, j = 0; i < n;) {\n        const c0 = table[base64.charCodeAt(i++)];\n        const c1 = table[base64.charCodeAt(i++)];\n        const c2 = table[base64.charCodeAt(i++)];\n        const c3 = table[base64.charCodeAt(i++)];\n        bytes[j++] = (c0 << 2) | (c1 >> 4);\n        bytes[j++] = (c1 << 4) | (c2 >> 2);\n        bytes[j++] = (c2 << 6) | c3;\n    }\n    return bytes;\n}\n/** @experimental */\nclass ReferenceStore {\n    #refs;\n    #opts;\n    #overrides;\n    constructor(refs, opts = {}) {\n        this.#refs = Promise.resolve(refs);\n        this.#opts = opts;\n        this.#overrides = opts.overrides || {};\n    }\n    async get(key, opts = {}) {\n        let ref = (await this.#refs).get(strip_prefix(key));\n        if (!ref)\n            return;\n        if (typeof ref === \"string\") {\n            if (ref.startsWith(\"base64:\")) {\n                return to_binary(ref.slice(\"base64:\".length));\n            }\n            return new TextEncoder().encode(ref);\n        }\n        let [urlOrNull, offset, size] = ref;\n        let url = urlOrNull ?? this.#opts.target;\n        if (!url) {\n            throw Error(`No url for key ${key}, and no target url provided.`);\n        }\n        let res = await fetch_range(uri2href(url), offset, size, merge_init(this.#overrides, opts));\n        if (res.status === 200 || res.status === 206) {\n            return new Uint8Array(await res.arrayBuffer());\n        }\n        throw new Error(`Request unsuccessful for key ${key}. Response status: ${res.status}.`);\n    }\n    static fromSpec(spec, opts) {\n        // @ts-expect-error - TS doesn't like the type of `parse`\n        let refs = Promise.resolve(spec).then((spec) => parse(spec));\n        return new ReferenceStore(refs, opts);\n    }\n    static fromUrl(url, opts) {\n        let spec = fetch(url, opts?.overrides).then((res) => res.json());\n        return ReferenceStore.fromSpec(spec, opts);\n    }\n}\nexport default ReferenceStore;\n"],"names":["parse","template","re","result","parts","pos","matchFn","str","match","fname","args","ctx","kwarg","key","num","_a","alphabet","numbers","expr","space","valid","matchMathEval","i","render","context","grp","inner","fnMatch","fn","matches","exprParts","value","spec","renderString","parseV1","parseV0","t","o","refs","ref","url","g","dims","iterDims","offset","length","dimensions","keys","iterables","range","values","product","iterators","it","results","r","stop","start","step","table","base64","n","bytes","j","c0","c1","c2","c3","to_binary","_ReferenceStore","opts","__privateAdd","_refs","_opts","_overrides","__privateSet","__privateGet","strip_prefix","urlOrNull","size","res","fetch_range","uri2href","merge_init","ReferenceStore"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}